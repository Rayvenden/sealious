var fs = require("fs")
var Set = require("Set")
var path = require("path");
var Core = require("prometheus-core");
var LayerManager = require("prometheus-layer-manager");
var ServiceWrapper = require("prometheus-service-wrapper");

var module_info = [];
var modules = {};


function Module(module_path){
	var settings_path = path.resolve(module_path, "package.json");
	var settings_json_string = fs.readFileSync(settings_path);
	var settings = JSON.parse(settings_json_string);
	var module_id  = settings["prometheus-module-id"];
	this.id = module_id;
	this.path = module_path;
	settings.executed = false; //used as a semaphore in register_modules function
	settings.requires = settings["prometheus-requires"];
	settings.defines = settings["prometheus-defines"]==undefined? [] : settings["prometheus-defines"];
	module_info[module_id] = settings;
	var defines = settings["prometheus-defines"];
	if(defines){
		for(var i in defines){
			Core.registerInjectable(defines[i]);
		}
	}
	modules[module_id] = this;

}

Module.prototype = new function(){

	this.channels_executed = false;
	this.services_executed = false;

	this.getAllInjectablesIDs = function(){
		//returns a combined array of both what the module defines and requires
		var requires = this.getInfo().requires;
		var defines = this.getInfo().defines;
		var ret_set = new Set();
		ret_set.addAll(requires? requires : []);
		ret_set.addAll(defines? defines : []);
		return ret_set.toArray();
	}

	this.getUsedChannelsIDs = function(){
		var injectables = this.getAllInjectablesIDs();
		var res =[];
		for(var i in injectables){
			var injectable_name = injectables[i];
			if(injectable_name.indexOf("channel.")==0){
				res.push(injectable_name);
			}
		}	
		return res;
	}

	this.getAllInjectables = function(){
		var ids = this.getAllInjectablesIDs();
		var res = [];
		for(var i in ids){
			var id = ids[i];
			var type = id.split(".")[0];
			switch(type){
				case "channel":
					res[id] = Core.getChannel(id.split(".")[1]);
					break;
				case "service":
					if(this.services_executed && LayerManager.isLocal()){
						res[id] = Core.getService(id.split(".")[1]);						
					}else{
						res[id] = new ServiceWrapper(id.split(".")[1])
					}
					break;
			}
		}
		return res;
	}

	this.getChannels = function(){
		var injectables = this.getAllInjectablesIDs();
		var ret = [];
		for(var i in injectables){
			if(injectables[i].indexOf("channel.")!=-1){
				var channel = Core.getChannel(injectables[i].slice("channel.".length));
				ret[injectables[i]] = channel;
			}
		}
		return ret;
	}

	this.getInfo = function(){
		return module_info[this.id];
	}

	this.register_channels = function(execute){
		if(!this.channels_registred){
			this.channels_registred = true;
			if(this.body.register_channels){
				var channel_ids = this.body.register_channels();
				var dependencies = [];
				for(var i in channel_ids){
					var current_channel_id = channel_ids[i];
					var channel_info = this.body.channel_info(current_channel_id);
					if(execute){
						var channel_body = this.body.channel_object(current_channel_id, dependencies);						
					}
					Core.registerChannel(current_channel_id, channel_info, channel_body)
				}
			}		
		}
		if(execute){
			this.channels_executed=true;
		}
	}

	this.register_services = function(execute){
		if(!this.services_registred){
			this.services_registred = true;
			if(this.body.register_services){
				var service_ids = this.body.register_services();
				var dependencies = this.getChannels();
				for(var i in service_ids){
					var current_service_id = service_ids[i];
					var service_info = this.body.service_info(current_service_id);
					if(execute){
						var service_body = this.body.service_object(current_service_id, dependencies);						
					}
					Core.registerService(current_service_id, service_info, service_body)
				}
			}
		}
		if(execute){
			this.services_executed=true;
		}
	}

	this.setup_channels = function(){
		var channel_ids = this.getUsedChannelsIDs();
		var dependencies = this.getAllInjectables();
		for(var i in channel_ids){
			var channel_id = channel_ids[i];
			if(this.body.channel_setup){
				this.body.channel_setup(channel_id, dependencies)
			}
		}		
	}

	this.post_execute_setup = function(){
		if(this.channels_executed){
			this.setup_channels();
		}
	}

	this.execute = function(scope){
		console.log("executing module",  this.id,  "with scope", scope);
		this.body = require(this.path);
		var execute_services = false;
		var execute_channels = false;
		for(var i in scope){
			switch(scope[i]){
				case "channels":
					execute_channels = true;
					break;
				case "services":
					execute_services = true;
					break;
				default:
					null;
					break;
			}
		}
		this.register_services(execute_services);
		this.register_channels(execute_channels);
		this.post_execute_setup();
	}

}

var modules_executed = false;



function decide_module_execution_order(scope){
	///scope is array of strings. Possible elements: "services", "channels"
	scope = scope==undefined? [] : scope;
	var all_modules_registred = false;
	var module_ids_in_order = [];
	var registred_injectables = new Set();
	var registred_ids = new Set();
	while(!all_modules_registred){
		var all_modules_registred = true;
		registred_in_this_iteration = 0;
		for(var i in module_info){
			if(registred_ids.has(i)){
				continue;
			}
			current_module_info = module_info[i];
			if(!current_module_info.registred){
				var can_execute = true;
				if(!current_module_info.requires){
					//value not set, no requirements;
				}else{
					for(var j in current_module_info.requires){
						if(!registred_injectables.has(current_module_info.requires[j])){
							can_execute = false;
						}
					}
				}
				if(can_execute){
					module_ids_in_order.push(i);
					registred_ids.add(i);
					registred_injectables.addAll(module_info[i].defines);
					registred_in_this_iteration = 1;
				}else{
					all_modules_registred = false;
				}

			}
		}
		if(registred_in_this_iteration == 0){
			throw new Error("Uresolvable modules dependencies")
		}
	}
	return module_ids_in_order
}


module.exports.execute_modules = function(scope){
	var id_order = decide_module_execution_order();
	console.log('module execution order:', id_order);
	for(var i in id_order){
		modules[id_order[i]].execute(scope);
	}
}

module.exports.loadPath = function(module_path){
	var module_id = path.basename(module_path);
	if(module_info[module_id]){
		//do nothing. module already loaded;
	}else{
		new Module(module_path);
	}
}